<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Beyond the basics with Cloud Foundry - Cong&#39;s little blog</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Beyond the basics with Cloud Foundry" />
<meta property="og:description" content="The advent of Docker changed the way we develop applications. Once you had written a Dockerfile and built the image, your application will run (almost) anywhere, regardless of the underlying operating system, and best of all, it just works. You can then expose ports, map volumes to persist data and deploy your image in Docker Swarm or Kubernetes (K8s). With great flexibility, however, comes greater costs, whether that is increased developer&rsquo;s skillset requirements and time spent on writing multiple K8s YAML config files, or pricier services on your favourite cloud provider." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://congx.dev/posts/beyond-the-basics-with-cloud-foundry/" />
<meta property="article:published_time" content="2019-06-12T23:00:00+11:00" />
<meta property="article:modified_time" content="2019-06-12T23:00:00+11:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Beyond the basics with Cloud Foundry"/>
<meta name="twitter:description" content="The advent of Docker changed the way we develop applications. Once you had written a Dockerfile and built the image, your application will run (almost) anywhere, regardless of the underlying operating system, and best of all, it just works. You can then expose ports, map volumes to persist data and deploy your image in Docker Swarm or Kubernetes (K8s). With great flexibility, however, comes greater costs, whether that is increased developer&rsquo;s skillset requirements and time spent on writing multiple K8s YAML config files, or pricier services on your favourite cloud provider."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
	<link rel="stylesheet" type="text/css" media="screen" href="https://congx.dev/css/main.css" />
</head><body>
        <div class="content"><header>
	<div class="main">
		<a href="https://congx.dev/">Cong&#39;s little blog</a>
	</div>
	<nav>
		
		<a href="/readme">README</a>
		
		<a href="/posts/">All posts</a>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Beyond the basics with Cloud Foundry</h1>
			<div class="meta">Posted on Jun 12, 2019</div>
		</div>
		

		<section class="body">
			

<p>The advent of Docker changed the way we develop applications. Once you had written a Dockerfile and built the image, your application will run (almost) anywhere, regardless of the underlying operating system, and best of all, it just works. You can then expose ports, map volumes to persist data and deploy your image in Docker Swarm or Kubernetes (K8s). With great flexibility, however, comes greater costs, whether that is increased developer&rsquo;s skillset requirements and time spent on writing multiple K8s YAML config files, or pricier services on your favourite cloud provider.</p>

<p>This blog post presents the usage of different tools and interesting tidbits to ease development with Cloud Foundry (CF), similar to the likes of Docker. These include:</p>

<ul>
<li>Developing and testing CF applications locally</li>
<li>Running Docker images inside a CF container</li>
<li>Sequencing start-ups of multiple CF applications</li>
<li>Configuring container-to-container networking</li>
</ul>

<p>For the remainder of this blog post, I will be using <a href="https://github.com/rampadc/toddler-auth">toddler-auth</a> as the example.</p>

<h1 id="which-cf-cli-to-use">Which CF CLI to use</h1>

<p>Just before we get started, if you are using the standalone IBM Cloud CLI, it bundles in CF CLI. Everything that comes after <code>ibmcloud cf</code> maps to the normal Cloud Foundry cf&rsquo;s command. Personally, because I use IBM Cloud day-to-day, I removed <code>cf</code> and created an alias to <code>ibmcloud cf</code> with <code>alias cf='ibmcloud cf'</code>. Henceforth, any mentions of <code>cf</code> refers to <code>ibmcloud cf</code>.</p>

<h1 id="developing-locally-with-cf-local">Developing locally with CF Local</h1>

<p><a href="https://pivotal.io/cf-local">CF Local</a> lets you develop locally and requires Docker to be installed. To install CF Local, invoke <code>cf install-plugin cflocal</code>. CF Local <a href="https://github.com/cloudfoundry-incubator/cflocal/issues/3">only</a> uses a <code>local.yml</code> instead of <code>manifest.yml</code>.</p>

<p>Writing <code>local.yml</code> is similar to a <code>docker-compose.yml</code> file. After all, they are YAML files. You can place multiple applications, specify environment variables just like any CF apps.</p>

<pre><code class="language-yaml">---
applications:
- name: toddler-auth
  routes:
    - route: toddler-auth.apps.internal
  memory: 128M
  disk_quota: 128M
  env:
    TODDLER_USERNAME: &lt;username&gt;
    TODDLER_PASSWORD: &lt;password&gt;
    TODDLER_WORLD_ID: &lt;worldId&gt;
</code></pre>

<p>Once you have navigated to the application folder, stage the application with <code>cf local stage toddler-auth</code>.</p>

<p>Staging the application&hellip;</p>

<p><img src="./stage.gif" alt="staging" /></p>

<p>Then, run the application with cf local run toddler-auth.</p>

<p>Running&hellip;</p>

<p><img src="./run.gif" alt="running" /></p>

<p>The first staging period can take some time to download buildpacks and set things up, but once it completes, CF Local creates <code>.cache</code> files inside the application&rsquo;s directory. Subsequent runs are faster.</p>

<h1 id="deploying-docker-images-into-cf-containers">Deploying Docker images into CF containers</h1>

<p><a href="https://www.cloudfoundry.org/blog/garden-and-runc/">Sometime in 2015</a>, Cloud Foundry started to support Docker images by adopting the Open Container Initiative (OCI) container execution interface. For more information on deploying a Docker image, have a look at the <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/push-docker.html">full documentation</a>. Two most important tidbits are:</p>

<ul>
<li>Only 1 exposed port per image is supported.</li>
<li>Exposed port is controlled by the <code>EXPOSE</code> directive in the Dockerfile.</li>
</ul>

<p>While you can control the exposed port by other means as outlined in the docs, using the default exposed port is the easiest way to go. An example to using a Docker image is provided in toddler-auth&rsquo;s <code>manifest.yml</code>:</p>

<pre><code class="language-yaml">---
applications:
- name: toddler-nats
  memory: 128M
  disk_quota: 256M
  docker:
    image: bitnami/nats:latest
  routes:
    - route: toddler-nats.apps.internal
</code></pre>

<p>In the above example, I am running an application named toddler-nats. It uses bitnami&rsquo;s nats.io image from Docker Hub and maps an internal route of <code>toddler-nats.apps.internal</code>.</p>

<h1 id="sequencing-applications-start-up">Sequencing applications start-up</h1>

<p>In the world of Docker Compose, Swarm and Kubernetes, applications are started in parallel. Applications startup sequence is not controlled by the orchestrator. This can be annoying as you need to write extra bash files and build in service availability detection.</p>

<p>On the contrary, if your manifest.yml contains multiple applications, CF applications are deployed in sequence during deployment from top to bottom. If any application in the chain fails, the entire deployment is halted. This is great if you need to sequence start-ups of multiple applications.</p>

<h1 id="configuring-container-to-container-networking">Configuring container-to-container networking</h1>

<p>Before touching on container-to-container networking, I just want to touch on why this was significant for my project.</p>

<h2 id="what-i-need-is-tcp-routing">What I need is TCP routing</h2>

<p>My Toddler stack relies on NATS as the centralised message queue for microservices&rsquo; communication. NATS is a great alternative to HTTP. It&rsquo;s got all the nice features of a message queue like pub/sub, topic routing, very high throughput and well-developed client libraries.</p>

<p>In mid-2016, Cloud Foundry <a href="https://www.cloudfoundry.org/blog/tcp-routing-comes-to-cloud-foundry/">rolled out support for TCP routing</a>. Not all cloud providers, however, support this feature. IBM Cloud for one, does not.</p>

<p><img src="./no-tcp-routing.png" alt="no-tcp" /></p>

<p>From the <a href="https://docs.cloudfoundry.org/devguide/deploy-apps/routes-domains.html#list-routes">listing routes</a> doc, if <code>tcp</code> is shown under type for any route, that route can be configured as a TCP route. Well, my public CF account does not. Searching around revealed that you can, however, set up custom TCP port with <a href="https://www.ibm.com/cloud/blog/cloud-foundry-container-to-container-networking">container-to-container networking (C2C networking)</a>.</p>

<h2 id="actually-configuring-c2c-networking">Actually configuring C2C networking</h2>

<p>Setting up C2C networking was straightforward. C2C networking is disabled by default. To enable C2C between 2 applications, you first need both apps deployed. Then, invoke</p>

<p><code>ibmcloud cf add-network-policy $SOURCE_APP_NAME --destination-app $DEST_APP_NAME --port $PORT --protocol tcp</code></p>

<p>For my project, I needed to enabled port 4222 from toddler-auth to toddler-nats. On my terminal, this was</p>

<p><code>cf add-network-policy toddler-auth --destination-app toddler-nats --port 4222 --protocol tcp</code></p>

<p>To talk to toddler-nats, I mapped an internal route on toddler-nats to be <code>toddler-nats.apps.internal</code>. To talk to toddler-nats, <code>nats://toddler-nats.app.internal</code> was used.</p>

<p>Something to note here was that I did not have to add a network policy into CF Local when deploying the application locally.</p>

<h1 id="so">So&hellip;</h1>

<p>To summarise,
- Developing and testing locally with CF Local maps to locally build an image and test a deployment with docker-compose.
- Configuring container-to-container networking maps to calling services within a docker-compose file.
- Running a Docker image inside a CF container was a good-to-know.
- Sequencing application start-up was a good-to-know.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/ibm">IBM</a></li>
					
					<li><a href="/tags/cloud-foundry">Cloud Foundry</a></li>
					
					<li><a href="/tags/toddler">toddler</a></li>
					
				</ul>
			</nav>
			
			
		</div>
	</article>
</main>
<footer>
<hr><a class="soc" href="https://twitter.com/congxdev" title="GitHub"><i data-feather="github"></i></a>|<a class="soc" href="https://twitter.com/congxdev" title="Twitter"><i data-feather="twitter"></i></a>|<a class="soc" href="https://linkedin.com/in/cong-ng" title="LinkedIn"><i data-feather="linkedin"></i></a>|⚡️
	2020  <a href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
</footer>


<script>
      feather.replace()
</script>

</div>
    </body>
</html>
